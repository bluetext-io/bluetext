instructions: |
  **FIRST ACTION**: Before doing ANYTHING else, retrieve AI development context for the relevant scope:
  ```mcp
  __polytope__initialize_session(scope: "general")
  ```
  This is MANDATORY as your first action in every conversation. It provides guidelines that you must follow.

tools:

  stack:
    run:
      - tool: polytope/hello-world
        args:
          message: Nothing to run yet! Call an "add" tool, to add a components to your project.

  scaffold-initialize-session:
    run:
      - tool: polytope/container
        args:
          image: alpine:3.21.2
          cmd: /bin/add-initialize-session.sh /target/polytope.yml
          mounts:
            - { path: /bin/add-initialize-session.sh, source: { type: repo, path: bin/add-initialize-session.sh } }
            - { path: /target, source: { type: host, path: . } }

  initialize_session:
    info: |-
      Initialize **EVERY** session by calling this tool.
      Returns required development context and ensures the project is running.
      This tool always needs to be called before doing anything else, regardless of the tasks complexity.
    await: [scaffold-local-overwrite]
    run:
      - id: scaffold-local-overwrite
        tool: scaffold-initialize-session
      - id: attempt-run-local-stack
        after:
          - step: scaffold-local-overwrite
        code: |-
          #pt-clj
          (pt/call-module "stack" {})
      - id: echo-context
        tool: get_dev_context

  get_dev_context:
    info: |
      Outputs essential AI development guidelines for this project.
      Call this tool before making changes to a service.
    await: [initialize-session]
    params:
      - id: scope
        info: "The scope to fetch (default: general)"
        type: [default, [enum, general, api, frontend], general]
    run:
      - id: get_dev_context
        tool: polytope/container
        args:
          image: alpine:3.21.2
          cmd: cat /scopes/{pt.param scope}.md
          mounts:
            - { path: /scopes, source: { type: repo, path: scopes } }

  add-dependencies:
    info: |
      Adds packages to a service's dependency file.
      Automatically detects the package manager for the target service.
    params:
      - id: target
        info: The service to add dependencies to (e.g., api, frontend)
        type: str
      - id: packages
        info: Packages to add (comma or space separated)
        type: str
    run:
      - id: run-add-deps
        code: |
          #pt-clj
          (let [target (:target params)
                packages (clojure.string/replace (:packages params) #"[\s,]+" " ")
                [cmd restart-policy] (case target
                                       "api" [(str "./bin/add-dependencies " packages) "never"]
                                       "frontend" [(str "bun add " packages) "on-failure"]
                                       (throw (Exception. (str "Unknown target: " target))))]
            (pt/call-module target {:id (str target "-add-deps")
                                   :cmd cmd
                                   :restart-policy restart-policy
                                   :create "always"}))

  scaffold:
    info: |
      Scaffolds a template to a specified path and adds it to project includes.
      Also scaffolds basic bluetext project structure if not already present, e.g. `lib/` folder.
      Use this for creating services, libraries, or any other template-based code.

      E.g. for an API:
        1. call `scaffold(template: "api", path: "services/my-api")`
        2. call `add-to-run-graph(target: "stack", tool: "my-api")`

    params:
      - id: template
        info: Template to scaffold into users directory.
        type: [enum, api, frontend, couchbase, temporal, postgres]
      - id: path
        info: Where to scaffold. For services use "services/<service-name>".
        type: [default, str, "services/api"]
      - id: on-conflict
        info: What to do if files already exist
        type: [default, [enum, skip, overwrite], skip]
    run:
      - id: scaffold-template
        tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: pt.param template}
              path: pt.param path
              on-conflict: pt.param on-conflict
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: lib/py/readme}
              path: lib/py/readme
              on-conflict: skip
      - id: add-to-includes
        after: {step: scaffold-template}
        tool: polytope/container
        args:
          image: alpine:3.21.2
          cmd: '#pt-js "/bin/add-to-includes.sh " + params.path + " /target/polytope.yml"'
          mounts:
            - { path: /bin/add-to-includes.sh, source: { type: repo, path: bin/add-to-includes.sh } }
            - { path: /target, source: { type: host, path: . } }

  add-to-run-graph:
    info: |
      Adds a tool to a run graph (like stack) and optionally runs it.
      Use this after scaffolding a service to make it part of your stack.

      IMPORTANT: Use the service name (NOT the full path).
      Example: After scaffolding to "services/api", use tool="api" (not "services/api")
    params:
      - id: tool
        info: Service/tool name to add (e.g., "api", "frontend", "postgres"). This is the name only, NOT the path.
        type: str
      - id: target
        info: Which graph/tool to add to
        type: [default, str, stack]
      - id: run
        info: Whether to run the tool after adding
        type: [default, bool, true]
    run:
      - id: add-to-target
        tool: polytope/container
        args:
          image: alpine:3.21.2
          cmd: '#pt-js "/bin/add-tool-to-run-graph.sh " + params.tool + " " + params.target + " /target/polytope.yml"'
          mounts:
            - { path: /bin/add-tool-to-run-graph.sh, source: { type: repo, path: bin/add-tool-to-run-graph.sh } }
            - { path: /target, source: { type: host, path: . } }
      - id: run-tool
        after: {step: add-to-target}
        code: |
          #pt-clj
          (when (:run params)
            (pt/call-module (:tool params) {}))

  add-integration:
    info: |
      Integrates a library into a service.
      Scaffolds the library if needed, then runs the service's integration script.
    params:
      - id: target-path
        info: Service to integrate into (e.g., api/src, frontend/app)
        type: str
      - id: integration
        info: Integration/library to add (e.g., postgres-client, couchbase-client, twilio-client, temporal-client)
        type: str
    run:
      - id: scaffold-lib
        tool: scaffold
        args:
          template: "lib/py/{pt.params integration}"
          path: "lib/py/{pt.params integration}"
          on-conflict: skip

      - id: scaffold-integration
        tool: scaffold
        args:
          template: "integrations/py/{pt.params integration}"
          path: "{pt.params target-path}/{pt.params integration}"
          on-conflict: skip
      - id: add-env-vars
        tool: run-script
        args:
          language: js
          script: |
            const{execSync}=require('child_process'),fs=require('fs');
            execSync('npm install yaml dotenv --prefix /tmp/d',{stdio:'pipe'});
            const Y=require('/tmp/d/node_modules/yaml'),D=require('/tmp/d/node_modules/dotenv');
            const env=D.parse(fs.readFileSync('/repo/{pt.param target-path}','utf8'));
            const doc=Y.parseDocument(fs.readFileSync('/repo/{pt.param yaml-file}','utf8'));
            const arr=doc.get('tools').get('api').get('run').get(0).get('args').get('env');
            const exist=new Set(arr.items.filter(i=>i.get).map(i=>i.get('name')));
            Object.entries(env).filter(([k])=>!exist.has(k)).forEach(([k,v])=>arr.add({name:k,value:v}));
            fs.writeFileSync('/repo/{pt.param yaml-file}',doc.toString());
            console.log('Added env vars');

      - id: run-integration-script
        after: {step: scaffold-lib}
        code: |
          #pt-clj
          (let [target (:target params)
                integration (:integration params)
                script (str "./bin/add-" integration)]
            (pt/call-module target {:id (str target "-add-" integration)
                                   :cmd script
                                   :restart-policy "never"
                                   :create "always"}))

  run-script:
    info: |
      Runs a custom script inside a service container.
      Useful for executing one-off commands or setup scripts.
      Exactly one of  script and path-to-script must be provided.
    params:
      - id: dependencies
        info: Service to run the script in (e.g., api, frontend)
        type: [maybe, [str]]
      - id: script
        info: Script/command to run
        type: [maybe, str]
      - id: path-to-script
        info: Path to a script file to run (alternative to 'script' param)
        type: [maybe, str]
      - id: language
        info: Language of the script (e.g., bash, python)
        type: [enum, bash, python, js]
      - id: repo
        info: Repository context to run the script in
        type: [default, str, .]
    run:
      - id: run-custom-script
        tool: polytope/run-script
        args:
          dependencies: pt.param dependencies
          script: |
            #pt-clj
            (cond 
              (:script params)
                {:type "string", :data (:script params)}
              (:path-to-script params)
                {:type "repo", :path (:path-to-script params)
              })
          language: pt.param language
          repo: {type: host, path: pt.param repo}

  api-add-postgres-client:
    info: |
      Adds PostgreSQL client library with database support to an API service.
      Run this after add-postgres to enable database operations in your API.
    params:
      - id: service-name
        info: Name of the API service to add the client to
        type: [default, str, api]
    run:
      - tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: lib/py/postgres-client}
              path: lib/py/postgres-client
              on-conflict: skip
      - id: run-script
        code: |
          #pt-clj
          (let [service-name (-> (:service-name params)
                                 (clojure.string/replace #"[^A-Za-z0-9-]*$" "")
                                 (clojure.string/replace #".*/" ""))
                tool-name (str service-name "-add-postgres-client")]
            (pt/call-tool tool-name {}))

  api-add-twilio-client:
    info: |
      Adds Twilio SMS client library to an API service.
      Enables SMS sending capabilities via Twilio's API.
    params:
      - id: service-name
        info: Name of the API service to add the client to
        type: [default, str, api]
    run:
      - tool: polytope/scaffold
        args:
          actions:
            - template: {type: repo, repo: "#pt-clj pt/module-repo-ref", path: lib/py/twilio-client}
              path: lib/py/twilio-client
              on-conflict: skip
      - id: run-script
        code: |
          #pt-clj
          (let [service-name (-> (:service-name params)
                                 (clojure.string/replace #"[^A-Za-z0-9-]*$" "")
                                 (clojure.string/replace #".*/" ""))
                tool-name (str service-name "-add-twilio-client")]
            (pt/call-tool tool-name {}))

