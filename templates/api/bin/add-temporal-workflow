#!/usr/bin/env bash
# Create a new Temporal workflow (activities managed separately with add-temporal-activity)

set -e

# Change to the api directory
cd "$(dirname "$0")/.."

workflows_dir=src/backend/workflows

# Function to echo (can be silenced)
echoh() {
    if [ "${SILENT_OUTPUT:-}" != "true" ]; then
        echo "$@"
    fi
}

# Function to convert kebab-case to snake_case
kebab_to_snake() {
    echo "$1" | sed 's/-/_/g'
}

# Function to convert kebab-case to PascalCase
kebab_to_pascal() {
    local input="$1"
    # Convert hyphens and underscores to spaces, then capitalize each word
    echo "$input" | sed 's/[-_]/ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2))}1' | sed 's/ //g'
}

# Function to convert to lowercase
to_lower() {
    echo "$1" | tr '[:upper:]' '[:lower:]'
}

# Function to ensure workflows directory and __init__.py exist
ensure_workflows_structure() {
    # Create workflows directory if it doesn't exist
    if [ ! -d "$workflows_dir" ]; then
        mkdir -p "$workflows_dir"
        echoh "üìÅ Created workflows directory: $workflows_dir"
    fi

    # Create __init__.py if it doesn't exist
    local init_file="${workflows_dir}/__init__.py"
    if [ ! -f "$init_file" ]; then
        cat > "$init_file" << 'EOF'
"""
Temporal workflows and activities registry.

All workflows and activities MUST be registered here for the Temporal worker to discover them.

Workflows are defined in this directory (workflows/).
Activities are defined separately in the activities/ directory.

IMPORTANT:
- Workflows are auto-registered by add-temporal-workflow
- Activities are auto-registered by add-temporal-activity
- Both import statements and registry lists are maintained automatically
"""

# Import workflows here (auto-added by add-temporal-workflow)

# Import activities here (auto-added by add-temporal-activity)

# Registry of all workflows
WORKFLOWS = [
]

# Registry of all activities
ACTIVITIES = [
]
EOF
        echoh "üìÑ Created workflows __init__.py: $init_file"
    fi
}

# Function to create workflow file
create_workflow_file() {
    local workflow_name="$1"
    local snake_name=$(kebab_to_snake "$workflow_name")
    local pascal_name=$(kebab_to_pascal "$workflow_name")
    local workflow_file="${workflows_dir}/${snake_name}.py"

    if [ -f "$workflow_file" ]; then
        echoh "üìÑ Workflow file already exists: $workflow_file"
        return 1
    fi

    cat > "$workflow_file" << EOF
"""
${pascal_name} workflow using Pydantic models for type-safe data transfer.

This demonstrates the recommended patterns for Temporal workflows:
1. Using Pydantic models instead of raw parameters
2. Proper workflow structure with activities defined separately
3. Clear separation of concerns between orchestration and execution

NOTE: Activities should be created separately using add-temporal-activity
"""
from datetime import timedelta

from pydantic import BaseModel
from temporalio import workflow
from ..utils.log import get_logger

logger = get_logger(__name__)

#### Constants ####

ACTIVITY_TIMEOUT_SECONDS = 10

#### Models ####

class ${pascal_name}Input(BaseModel):
    """
    Pydantic model for workflow input.

    NOTE: Binary data should be base64-encoded as strings. Complex objects may
    need custom converters. The pydantic_data_converter handles Pydantic model
    serialization automatically.
    """
    placeholder: str


class ${pascal_name}Response(BaseModel):
    """Pydantic model for workflow output."""
    placeholder: str

#### Workflow ####

@workflow.defn
class ${pascal_name}Workflow:
    """
    Workflows orchestrate activities and define the business logic flow.

    Workflows must be deterministic - avoid random numbers, current time, or external
    API calls directly in workflow code. Use activities for non-deterministic
    operations.

    IMPORTANT: If you rename the workflow class, update workflows/__init__.py
    to import the new class name and add it to the WORKFLOWS list.

    Activities should be created separately using: add-temporal-activity
    """

    @workflow.run
    async def run(self, input: ${pascal_name}Input) -> ${pascal_name}Response:
        """
        The main workflow entry point.

        This method defines the workflow's execution logic. It can:
        - Execute activities with retries and timeouts
        - Make decisions based on activity results
        - Handle errors and compensate for failures
        - Wait for external signals or timers

        TODO: Import and execute activities here. Example:

        from ..activities.your_activity import your_activity_function

        result = await workflow.execute_activity(
            your_activity_function,
            args=[input],
            start_to_close_timeout=timedelta(seconds=ACTIVITY_TIMEOUT_SECONDS),
        )

        return result
        """
        workflow.logger.info(f"Running workflow with input: {input}")

        # TODO: Implement workflow logic and execute activities
        return ${pascal_name}Response(
            placeholder=input.placeholder
        )
EOF

    echoh "‚úÖ Created workflow file: $workflow_file"
    return 0
}

# Function to update workflows/__init__.py
update_workflows_init() {
    local workflow_name="$1"
    local snake_name=$(kebab_to_snake "$workflow_name")
    local pascal_name=$(kebab_to_pascal "$workflow_name")
    local init_file="${workflows_dir}/__init__.py"

    # Check if already imported
    if grep -q "from .${snake_name} import ${pascal_name}Workflow" "$init_file" 2>/dev/null; then
        echoh "‚úì Workflow already registered in $init_file"
        return 0
    fi

    # Add import statement after any existing imports or after docstring
    import_line="from .${snake_name} import ${pascal_name}Workflow"

    # Use awk to find the right place: after last import or before WORKFLOWS if no imports
    awk -v import_line="$import_line" '
    BEGIN { inserted = 0; in_imports = 0 }

    # Track if we are seeing imports
    /^from \.|^import / {
        in_imports = 1
        print
        next
    }

    # If we were in imports and now hit a non-import, insert here
    in_imports && !/^from \.|^import / && !inserted {
        print import_line
        print ""
        inserted = 1
        in_imports = 0
    }

    # If we hit WORKFLOWS without inserting yet, insert before it
    /^WORKFLOWS = \[/ && !inserted {
        print ""
        print import_line
        print ""
        inserted = 1
    }

    # Print all other lines
    { print }
    ' "$init_file" > "${init_file}.tmp" && mv "${init_file}.tmp" "$init_file"

    # Update WORKFLOWS list - find first standalone ] and add entry before it
    if grep -q "WORKFLOWS = \[" "$init_file"; then
        workflow_entry="    ${pascal_name}Workflow,"

        # Use awk to add before the first standalone closing bracket after WORKFLOWS
        awk -v entry="$workflow_entry" '
        /^WORKFLOWS = \[/ { in_workflows = 1 }
        in_workflows && /^\]$/ && !added {
            print entry
            added = 1
        }
        { print }
        ' "$init_file" > "${init_file}.tmp" && mv "${init_file}.tmp" "$init_file"
    fi

    echoh "üìù Registered workflow in $init_file"
}

# Main script
main() {
    # Parse arguments
    local workflow_name=""

    if [[ $# -eq 1 ]]; then
        workflow_name="$1"
    else
        echo "Usage: $0 <workflow-name>"
        echo ""
        echo "Scaffold a new Temporal workflow (activities created separately)"
        echo ""
        echo "To create activities, use: add-temporal-activity <activity-name>"
        exit 0
    fi

    echoh "üì¶ Creating Temporal workflow: $workflow_name"
    echoh ""

    # Ensure workflows directory structure exists
    ensure_workflows_structure

    # Convert workflow name to snake_case for file paths
    local snake_name=$(kebab_to_snake "$workflow_name")
    local pascal_name=$(kebab_to_pascal "$workflow_name")

    # Create the workflow file
    create_workflow_file "$workflow_name"

    # Update __init__.py
    update_workflows_init "$workflow_name"

    echoh ""
    echoh "üéâ Workflow created successfully!"
    echoh ""
    echoh "Next steps:"
    echoh "1. READ the generated workflow file first to understand the structure:"
    echoh "   ${workflows_dir}/${snake_name}.py"
    echoh ""
    echoh "2. Create activities separately using:"
    echoh "   ./bin/add-temporal-activity <activity-name>"
    echoh ""
    echoh "3. Edit the workflow file to import and execute your activities:"
    echoh "   ${workflows_dir}/${snake_name}.py"
    echoh ""
    echoh "4. Use the workflow in your routes:"
    echoh "   from temporalio.client import Client"
    echoh "   from backend.workflows.${snake_name} import ${pascal_name}Workflow, ${pascal_name}Input"
    echoh ""
    echoh "   # Get client from FastAPI app state"
    echoh "   temporal_client = request.app.state.temporal_client"
    echoh ""
    echoh "   # Start workflow"
    echoh "   handle = await temporal_client.start_workflow("
    echoh "       ${pascal_name}Workflow.run,"
    echoh "       args=[${pascal_name}Input(placeholder=\"example-value\")],"
    echoh "       id=\"${snake_name}-\${uuid4()}\","
    echoh "       task_queue=\"main-task-queue\""
    echoh "   )"
    echoh ""
    echoh "   # Get result"
    echoh "   result = await handle.result()"
}

# Run main function
main "$@"
